#version 460 core

#define CLUSTER_MAX_LIGHTS 256		// the maximum number of lights per cluster
#define OPTIMUM_TILE_COUNT 144		// the target number of clusters per depth

layout (local_size_x = OPTIMUM_TILE_COUNT, local_size_y = 1, local_size_z = 1) in;

struct PointLight {
	vec4 position;
	vec4 color;
	vec4 radius;
};

struct AABB {		// axis aligned bounding box
	vec4 minPoint;	// + padding
	vec4 maxPoint;	// + padding
};

struct LightArray {
	uint begin;
	uint end;
};

// buffers
layout(std430, binding = 0) readonly buffer RenderData {
    mat4 invProj;
	uvec3 clusterSize;
	float bias;
	uvec2 screenSize;
	float scale;
	float zNear;
	float zFar;
};

layout(std430, binding = 1) readonly buffer ClusterBuffer {
	AABB clusters[];
};

layout(std430, binding = 2) readonly buffer LightBuffer {
	PointLight lights[];
};

layout(std430, binding = 3) writeonly buffer IndicesBuffer {
	uint lightIndices[];
};

layout(std430, binding = 4) writeonly buffer LightArrayBuffer {
	LightArray lightArrays[];
};

layout(std430, binding = 5) buffer LightCountBuffer {
	uint visibleCount;
};

uniform mat4 view;
uniform int lightCount;

// functions
bool SphereIntersectAABB(vec3 position, float r, vec3 bMin, vec3 bMax) {
    vec3 c = vec3(view * vec4(position, 1));
	float sqDist = 0;
    for (int i = 0; i < 3; i++) {
        if (c[i] < bMin[i]) sqDist += pow(c[i] - bMin[i], 2); else 
		if (c[i] > bMax[i]) sqDist += pow(c[i] - bMax[i], 2);
    }
    return sqDist <= (r * r);
}

// for each cluster
void main() {
	uint threadCount = clusterSize.x * clusterSize.y;	// number of local active invocations
	uint clusterID = threadCount * gl_WorkGroupID.z +	// Index to unique cluster
				     gl_LocalInvocationID.x;								
	
	visibleCount = 0;									// initialize global count to 0
	uint localCount = 0;								// initialize local count to 0
    
	uint localIndices[CLUSTER_MAX_LIGHTS];				// temporary array for local lights found
	
	if (gl_LocalInvocationID.x < threadCount)			// only search for lights in active invocations
	{
		for(uint lightID = 0; lightID < lightCount; lightID++)				// for each light in the scene
		{
			PointLight light = lights[lightID];
			AABB boundBox = clusters[clusterID];

			if(SphereIntersectAABB(light.position.xyz, light.radius.r, boundBox.minPoint.xyz, boundBox.maxPoint.xyz))	// is light in cluster AABB
			{
				localIndices[localCount] = lightID;			// add light to local collection
				localCount += 1;							// count lights
				
				if (localCount == CLUSTER_MAX_LIGHTS)
					break;
			}
		}
	}

	barrier();
	// get the global count and atomically add local count
	uint globalIndex = atomicAdd(visibleCount, localCount);
	
	if (gl_LocalInvocationID.x < threadCount)
	{
		// set array index and count
		lightArrays[clusterID] = LightArray(globalIndex, globalIndex + localCount);						
	
		// copy index into global index buffer at lightArray
		for(int i = 0; i < localCount; i++)
			lightIndices[globalIndex + i] = localIndices[i];
	}
};
